/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.10/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the application plugin to add support for building a CLI application in Java.
    id 'application'
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

configurations {
    packIntoJAR
}

dependencies {
    // Use JUnit Jupiter for testing.
    testImplementation libs.junit.jupiter
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    //https://mvnrepository.com/artifact/org.json/json
    implementation 'org.json:json:20240303'
    packIntoJAR 'org.json:json:20240303'

    // This dependency is used by the application.
    implementation libs.guava
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(8)
    }
}

application {
    // Define the main class for the application.
    mainClass = 'de.hellbz.MinecraftServerInstaller.MainInstaller'
}

tasks.named('test') {
    // Use JUnit Platform for unit tests.
    useJUnitPlatform()
}

apply plugin: 'java'

import groovy.json.JsonSlurper
import java.text.SimpleDateFormat

// Pfad zur JSON-Datei im res-Ordner
def versionFile = file('src/main/resources/installerInfo.json')

// Lese und parse die JSON-Datei
def versionData = new JsonSlurper().parseText(versionFile.text)

// Extrahiere die Version aus der JSON-Datei
def version = versionData.version

// Setze die Version für das Projekt
project.version = version

import java.text.SimpleDateFormat
// Erstelle einen Timestamp
def timestamp = new SimpleDateFormat("yyyyMMddHHmmss").format(new Date())

def timestampOnlyDay = new SimpleDateFormat("yyyy-MM-dd").format(new Date())

jar {
    // Optional: Setze den vollständigen Namen der JAR-Datei
    archiveBaseName.set("${timestamp}-${rootProject.name}") // Verwendet den Namen des Root-Projekts

    // Setze das Verzeichnis, in dem die JAR-Datei gespeichert werden soll
    destinationDirectory.set(file("compiled/${timestampOnlyDay}/${project.version}/"))
    manifest {
        attributes(
                'Main-Class': "de.hellbz.MinecraftServerInstaller.MainInstaller"
        )
    }

    // Füge nur die Abhängigkeiten aus der customRuntime-Konfiguration ein
    from {
        configurations.packIntoJAR.collect {
            it.isDirectory() ? it : zipTree(it)
        }
    }

    // Inkludiere die kompilierten Klassen aus dem Projekt
    from(sourceSets.main.output)

    // Inkludiere alle Ressourcen aus dem Modules-Ordner (z. B. XML, JSON)
    from(file('src/main/java/de/hellbz/MinecraftServerInstaller/Modules')) {
        include '**/*'
        exclude '**/*.java' // Schließt die .java-Dateien aus, da diese kompiliert werden
        into 'de/hellbz/MinecraftServerInstaller/Modules'
    }

}

// Registriere den Task zum Erstellen der zusätzlichen Datei
tasks.register('createStartFile') {

    def outputFile = file("compiled/${timestampOnlyDay}/${project.version}/_start_.bat")
    doLast {
        outputFile.parentFile.mkdirs()
        outputFile.text = """
        @echo off
        echo Build Date: ${new Date()}
        echo Project Name: ${rootProject.name}
        java -jar ${timestamp}-${rootProject.name}-${project.version}.jar
        pause
        """
        println "Created file: ${outputFile.path}"
    }
}

// Kompiliere die Hauptklassen im Standard-Build-Prozess
sourceSets.main.java.srcDirs = ['src/main/java']

// Task für das Kompilieren der Plugins
tasks.register('compilePlugins', JavaCompile) {
    source = fileTree('src/main/java/de/hellbz/MinecraftServerInstaller/Modules') {
        include '**/*.java'
    }
    classpath = sourceSets.main.output + configurations.compileClasspath
    destinationDir = file("$buildDir/classes/MinecraftServerInstaller/Modules")

    doFirst {
        println "Compiling plugin sources..."
        source.each { println it }
    }
}


// Definiere den buildPlugins-Task
tasks.register('buildPlugins') {
    dependsOn 'build' // Stellt sicher, dass das gesamte Projekt zuerst gebaut wird
    dependsOn 'compilePlugins'
    doLast {
        println "All plugins have been built."
    }
}

// Registriere JAR-Tasks für die Plugins
file('src/main/java/de/hellbz/MinecraftServerInstaller/Modules').eachDir { dir ->
    def jarTaskName = "compilePlugin_${dir.name}"
    tasks.register(jarTaskName, Jar) {
        dependsOn 'compilePlugins'
        archiveBaseName.set("${dir.name}")

        // Füge die kompilierten Klassen hinzu
        from(file("$buildDir/classes/MinecraftServerInstaller/Modules/de/hellbz/MinecraftServerInstaller/Modules/${dir.name}")) {
            include '**/*'
            // Entferne den führenden Pfad, um die richtige Struktur in der JAR zu bekommen
            into "de/hellbz/MinecraftServerInstaller/Modules/${dir.name}"
        }
        destinationDirectory.set(file("compiled/${timestampOnlyDay}/${project.version}/msi_data/modules/"))

        // Füge alle anderen Dateien aus dem Plugin-Ordner hinzu (Bilder, XML, JSON, etc.)
        from(dir) {
            include '**/*' // Schließt alle Dateien ein
            exclude '**/*.java' // Schließt die .java-Dateien aus, da diese kompiliert wurden
            into "de/hellbz/MinecraftServerInstaller/Modules/${dir.name}"
        }

        manifest {
            attributes(
                    'Main-Class': "de.hellbz.MinecraftServerInstaller.Modules.${dir.name}.${dir.name}"
            )
        }
    }

    tasks.named('buildPlugins').configure {
        dependsOn jarTaskName
    }
}

// Stellt sicher, dass der Build-Prozess den Plugin-Build und die Dateierstellung umfasst
tasks.named('build') {
    dependsOn 'createStartFile' // , 'buildPlugins'
}

task customFatJar(type: Jar) {
    manifest {
        attributes 'Main-Class': "de.hellbz.MinecraftServerInstaller.MainInstaller"
    }
    archiveBaseName = 'all-in-one-jar'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}